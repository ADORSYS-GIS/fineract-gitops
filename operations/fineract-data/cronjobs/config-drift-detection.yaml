apiVersion: batch/v1
kind: CronJob
metadata:
  name: config-drift-detection
  labels:
    app: fineract-operations
    job-type: monitoring
spec:
  # Run every 6 hours
  schedule: "0 */6 * * *"

  # Keep last 3 successful and 3 failed jobs
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3

  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 86400  # Keep for 24 hours
      backoffLimit: 2

      template:
        metadata:
          labels:
            app: fineract-operations
        spec:
          restartPolicy: OnFailure

          containers:
          - name: drift-detector
            image: python
            command:
            - sh
            - -c
            - |
              # ==============================================================
              # HARDCODED PIP INSTALL IN CONTAINER COMMAND
              # ==============================================================
              # CURRENT APPROACH: Install Python packages at runtime
              #
              # ISSUES:
              # - Slow startup (downloads packages every run)
              # - Network dependency (fails if PyPI unreachable)
              # - Non-deterministic (package versions can change)
              # - Wasted resources (repeated downloads)
              # - No vulnerability scanning
              #
              # RECOMMENDED ALTERNATIVE: Custom Docker image
              # Create a Dockerfile:
              #   FROM python:3.11-slim
              #   RUN pip install --no-cache-dir pyyaml==6.0.1 requests==2.31.0
              #   COPY detect_drift.py /app/
              #   WORKDIR /app
              #   CMD ["python3", "detect_drift.py"]
              #
              # Benefits:
              # - Fast startup (no runtime installs)
              # - Deterministic (pinned versions)
              # - Offline-capable (no PyPI dependency)
              # - Security scanning (in CI/CD)
              # - Smaller attack surface
              #
              # CURRENT JUSTIFICATION:
              # - Acceptable for: Dev, infrequent jobs, prototyping
              # - Not recommended for: Production, frequent executions
              # - Trade-off: Simplicity vs performance
              #
              # Install dependencies
              pip install -q pyyaml requests

              # ==============================================================
              # HARDCODED FINERACT URL FOR DRIFT DETECTION
              # ==============================================================
              # CURRENT APPROACH: Hardcoded service URL
              #
              # ISSUES:
              # - Not environment-agnostic
              # - Requires YAML changes for different envs
              # - Violates 12-factor app principles
              #
              # RECOMMENDED ALTERNATIVE: ConfigMap injection
              # Example:
              #   env:
              #   - name: FINERACT_URL
              #     valueFrom:
              #       configMapKeyRef:
              #         name: fineract-config
              #         key: read-service-url
              #
              # Then use: --fineract-url "${FINERACT_URL}"
              #
              # Benefits:
              # - Environment-specific via Kustomize overlays
              # - No YAML edits needed for different envs
              # - Follows GitOps patterns
              #
              # CURRENT JUSTIFICATION:
              # - Service name is consistent across envs
              # - K8s DNS resolves to correct service
              # - Acceptable for single-cluster deployments
              #
              # Run drift detection
              python3 /scripts/detect_drift.py \
                --yaml-dir /data \
                --fineract-url http://fineract-read-service:8080/fineract-provider/api/v1 \
                --tenant default \
                --alert-webhook "${SLACK_WEBHOOK_URL}"

            # ==================================================================
            # SENSITIVE DATA IN ENVIRONMENT VARIABLES
            # ==================================================================
            # See operations/fineract-data/scripts/loaders/base_loader.py
            # lines 41-163 for comprehensive security documentation
            #
            env:
            # OAuth2 Client Credentials (preferred authentication method)
            - name: FINERACT_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  name: fineract-admin-credentials
                  key: client-id
            - name: FINERACT_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: fineract-admin-credentials
                  key: client-secret
            - name: FINERACT_TOKEN_URL
              valueFrom:
                secretKeyRef:
                  name: fineract-admin-credentials
                  key: token-url

            # ==================================================================
            # SENSITIVE DATA WITH OPTIONAL: TRUE
            # ==================================================================
            # CURRENT APPROACH: Alert credentials marked as optional
            #
            # TRADE-OFFS:
            # - Pro: Job doesn't fail if alerting not configured
            # - Pro: Allows gradual rollout (dev without alerts, prod with)
            # - Pro: Flexible deployment (some envs may use Slack, others email)
            # - Con: Silent failures if misconfigured
            # - Con: Drift may go unnoticed if alerts don't work
            # - Con: Hard to distinguish "no alerts" from "broken alerts"
            #
            # ALERTING STRATEGY:
            # The optional flag supports a tiered alerting approach:
            # - Dev: No alerting (optional secrets not created)
            # - Staging: Slack only (only slack-credentials created)
            # - Production: Slack + Email (both secrets created)
            #
            # ALTERNATIVE APPROACHES:
            # 1. Required secrets for production (RECOMMENDED):
            #    Use Kustomize overlays to make secrets non-optional in prod:
            #
            #    environments/production/kustomization.yaml:
            #      patches:
            #      - target:
            #          kind: CronJob
            #          name: config-drift-detection
            #        patch: |-
            #          - op: remove
            #            path: /spec/jobTemplate/spec/template/spec/containers/0/env/6/valueFrom/secretKeyRef/optional
            #
            #    This enforces secrets in production while keeping them optional in dev.
            #
            # 2. Fail-safe validation in script:
            #    Add to detect_drift.py:
            #      import os
            #      ENV = os.getenv('ENVIRONMENT', 'dev')
            #      if ENV == 'production':
            #          if not os.getenv('SLACK_WEBHOOK_URL'):
            #              raise RuntimeError("SLACK_WEBHOOK_URL required in production")
            #
            #    This provides early failure with clear error messages.
            #
            # 3. Health check probe:
            #    Add liveness probe that tests alerting mechanism:
            #      livenessProbe:
            #        exec:
            #          command:
            #          - python3
            #          - -c
            #          - |
            #            import os
            #            # Verify at least one alert mechanism configured
            #            if not (os.getenv('SLACK_WEBHOOK_URL') or os.getenv('SMTP_HOST')):
            #                exit(1)
            #        initialDelaySeconds: 5
            #
            # 4. Dead letter queue / fallback:
            #    If primary alerting fails, write to persistent log:
            #      volumeMounts:
            #      - name: alert-failures
            #        mountPath: /var/log/alert-failures
            #
            #    Script logs to file if alerting unavailable.
            #    Separate monitoring watches this log.
            #
            # MONITORING RECOMMENDATIONS:
            # - Monitor CronJob success/failure rates (should be > 95%)
            # - Alert if CronJob hasn't run in expected timeframe
            # - Track drift detection findings in metrics
            # - Test alerting mechanisms regularly (synthetic drift)
            #
            # CURRENT JUSTIFICATION:
            # - Acceptable for: Multi-environment deployments with varied requirements
            # - Required for production: At least one alerting mechanism should be mandatory
            # - Recommendation: Use Kustomize patches to enforce in prod
            #
            - name: SLACK_WEBHOOK_URL
              valueFrom:
                secretKeyRef:
                  name: slack-credentials
                  key: webhook-url
                  optional: true  # See documentation above

            # Email/SMTP Configuration
            - name: SMTP_HOST
              valueFrom:
                secretKeyRef:
                  name: smtp-credentials
                  key: host
                  optional: true  # See documentation above
            - name: SMTP_PORT
              valueFrom:
                secretKeyRef:
                  name: smtp-credentials
                  key: port
                  optional: true  # See documentation above
            - name: SMTP_USERNAME
              valueFrom:
                secretKeyRef:
                  name: smtp-credentials
                  key: username
                  optional: true  # See documentation above
            - name: SMTP_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: smtp-credentials
                  key: password
                  optional: true  # See documentation above
            - name: SMTP_USE_TLS
              value: "true"
            - name: ALERT_EMAIL_FROM
              valueFrom:
                secretKeyRef:
                  name: smtp-credentials
                  key: from-address
                  optional: true  # See documentation above
            - name: ALERT_EMAIL_TO
              valueFrom:
                secretKeyRef:
                  name: smtp-credentials
                  key: to-address
                  optional: true  # See documentation above

            volumeMounts:
            - name: drift-scripts
              mountPath: /scripts
            - name: config-data
              mountPath: /data

            resources:
              requests:
                memory: "256Mi"
                cpu: "100m"
              limits:
                memory: "512Mi"
                cpu: "500m"

          volumes:
          - name: drift-scripts
            configMap:
              name: fineract-drift-detection-scripts
          # ====================================================================
          # PROJECTED VOLUMES FOR DATA
          # ====================================================================
          # CURRENT APPROACH: Manual list of ConfigMaps in projected volume
          #
          # ISSUES:
          # - Requires manual updates when adding new data sources
          # - Easy to forget ConfigMaps (incomplete drift detection)
          # - Maintenance burden (keep in sync with data directories)
          # - Human error prone
          # - No validation that all sources are included
          #
          # ALTERNATIVE APPROACHES:
          #
          # 1. Kustomize ConfigMapGenerator with directory (RECOMMENDED):
          #    kustomization.yaml:
          #      configMapGenerator:
          #      - name: all-fineract-data
          #        files:
          #        - data/loan-products/*.yaml
          #        - data/offices/*.yaml
          #        - data/clients/*.yaml
          #        # Kustomize automatically bundles all files
          #
          #    Then in CronJob:
          #      volumes:
          #      - name: config-data
          #        configMap:
          #          name: all-fineract-data
          #
          #    Benefits:
          #    - Automatic: No manual list maintenance
          #    - Complete: All YAML files included
          #    - Single source of truth
          #    Cons:
          #    - Large ConfigMap (may hit 1MB etcd limit)
          #    - All-or-nothing updates
          #
          # 2. Dynamic volume generation script:
          #    Create a script that generates the volume definition:
          #      scripts/generate-drift-volume.sh:
          #        #!/bin/bash
          #        echo "projected:"
          #        echo "  sources:"
          #        kubectl get configmaps -l data-type=fineract -o name | while read cm; do
          #          echo "  - configMap:"
          #          echo "      name: ${cm#configmap/}"
          #        done
          #
          #    Run during CI/CD to update CronJob manifest.
          #
          #    Benefits:
          #    - Automated based on labels
          #    - Flexible filtering
          #    Cons:
          #    - Requires CI/CD integration
          #    - Indirect (generated YAML committed to Git)
          #
          # 3. Init container that discovers ConfigMaps:
          #    Add init container that queries K8s API for ConfigMaps:
          #      initContainers:
          #      - name: gather-configs
          #        image: kubectl:latest
          #        command:
          #        - sh
          #        - -c
          #        - |
          #          kubectl get configmaps -l data-type=fineract -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' > /tmp/configmaps
          #          # Download all ConfigMaps to shared volume
          #          while read cm; do
          #            kubectl get configmap $cm -o yaml > /data/$cm.yaml
          #          done < /tmp/configmaps
          #        volumeMounts:
          #        - name: config-data
          #          mountPath: /data
          #
          #    Benefits:
          #    - Fully dynamic at runtime
          #    - No manifest updates needed
          #    Cons:
          #    - Requires RBAC permissions (ServiceAccount)
          #    - More complex
          #    - Slower startup
          #
          # 4. Single aggregated ConfigMap (SIMPLEST):
          #    Create one ConfigMap with all data:
          #      kubectl create configmap fineract-all-data \
          #        --from-file=data/loan-products/ \
          #        --from-file=data/offices/ \
          #        --from-file=data/clients/
          #
          #    Then:
          #      volumes:
          #      - name: config-data
          #        configMap:
          #          name: fineract-all-data
          #
          #    Benefits:
          #    - Simplest approach
          #    - No projected volume complexity
          #    Cons:
          #    - Manual creation/updates
          #    - Size limits (1MB)
          #    - Less granular updates
          #
          # 5. Makefile/Script automation (RECOMMENDED for current setup):
          #    Create Makefile target:
          #      .PHONY: update-drift-volume
          #      update-drift-volume:
          #        @echo "Updating config-drift-detection.yaml projected volume..."
          #        @echo "          - name: config-data" > /tmp/volume.yaml
          #        @echo "            projected:" >> /tmp/volume.yaml
          #        @echo "              sources:" >> /tmp/volume.yaml
          #        @find data/ -name '*.yaml' -type f | cut -d/ -f2 | sort -u | while read dir; do \
          #          echo "              - configMap:" >> /tmp/volume.yaml; \
          #          echo "                  name: $${dir}-data" >> /tmp/volume.yaml; \
          #        done
          #        @# Replace volume definition in YAML
          #        @sed -i '/name: config-data/,/# Add all/d' config-drift-detection.yaml
          #        @cat /tmp/volume.yaml >> config-drift-detection.yaml
          #
          #    Run: make update-drift-volume
          #
          #    Benefits:
          #    - Automated but predictable
          #    - Git-trackable changes
          #    - Works with existing structure
          #    Cons:
          #    - Requires manual execution
          #    - Could be forgotten
          #
          # RECOMMENDED APPROACH:
          # For current GitOps setup: Use Kustomize ConfigMapGenerator (#1)
          # For dynamic environments: Use init container (#3)
          # For simplicity: Use Makefile automation (#5)
          #
          # CURRENT JUSTIFICATION:
          # - Manual list acceptable for: Stable configuration, small number of sources
          # - Not scalable for: Frequent additions, large number of data sources
          # - Recommendation: Implement Makefile target as interim solution
          #
          - name: config-data
            projected:
              sources:
              - configMap:
                  name: loan-products-data
              - configMap:
                  name: offices-data
              # TODO: Add remaining config data sources or implement automation
              # See documentation above for recommended approaches
