apiVersion: batch/v1
kind: Job
metadata:
  name: export-keycloak-secrets
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/sync-wave: "10"
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: keycloak-secret-exporter
      containers:
      - name: secret-exporter
        image: registry.k8s.io/kubectl:v1.32.1
        env:
        # Configuration from ConfigMap
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: KEYCLOAK_URL
          valueFrom:
            configMapKeyRef:
              name: keycloak-config-vars
              key: keycloak-url
              optional: false
        command:
        - /bin/bash
        - -c
        - |
          /scripts/export-client-secrets.sh
        volumeMounts:
        - name: scripts
          mountPath: /scripts
      volumes:
      - name: scripts
        configMap:
          name: keycloak-exporter-scripts
          defaultMode: 0755  # Changed from 0777 for better security
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: keycloak-exporter-scripts
data:
  export-client-secrets.sh: |
    #!/bin/bash
    set -e
    # This script exports client secrets from Keycloak and creates a Kubernetes secret.
    # It requires kubectl and jq to be installed.

    # Configuration from environment variables (set by container env)
    # NAMESPACE is auto-injected from fieldRef
    # KEYCLOAK_URL is from keycloak-config-vars ConfigMap

    # Get Keycloak pod name (assumes Keycloak runs in same namespace)
    KEYCLOAK_POD=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=keycloak -o jsonpath='{.items[0].metadata.name}')
    ADMIN_USER="admin"
    ADMIN_PASSWORD=$(kubectl get secret -n keycloak keycloak-admin-credentials -o jsonpath='{.data.password}' | base64 --decode)
    SECRET_NAME="keycloak-client-secrets"

    # Hardcoded CLIENTS list - matches clients defined in realm-fineract.yaml
    # RATIONALE for hardcoded list:
    # - Predictable: Ensures we only export secrets for known, expected clients
    # - Security: Prevents accidental export of service account secrets (admin-cli, fineract-api)
    # - Simplicity: Avoids complex Keycloak API queries and filtering logic
    # - Maintainability: Changes to clients require explicit updates here (intentional friction)
    # ALTERNATIVE: Dynamic retrieval using Keycloak REST API
    # - Query all clients in fineract realm
    # - Filter by client type (publicClient=false, serviceAccountsEnabled=false)
    # - More automated but less predictable and harder to debug
    # CURRENT APPROACH: Explicit list matches realm config (realm-fineract.yaml)
    # NOTE: This job is deprecated in favor of pre-generated sealed secrets
    # See: scripts/create-complete-sealed-secrets.sh for production approach
    CLIENTS=("apache-gateway" "message-gateway" "payment-gateway" "community-app" "mifos-mobile" "web-app")
    echo "Exporting client secrets from Keycloak..."
    # Create a temporary file to store the secrets
    SECRETS_FILE=$(mktemp)
    # Authenticate with Keycloak
    kubectl exec -n keycloak $KEYCLOAK_POD -- /opt/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080 --realm master --user "$ADMIN_USER" --password "$ADMIN_PASSWORD"
    # Get client secrets
    for client in "${CLIENTS[@]}"; do
      echo "Getting secret for client: $client"
      secret=$(kubectl exec -n keycloak $KEYCLOAK_POD -- /opt/keycloak/bin/kcadm.sh get clients -r fineract -q "clientId=$client" --fields 'secret' -o json | jq -r '.[0].secret')
      echo "  $client: $secret" >> "$SECRETS_FILE"
    done
    # Create the Kubernetes secret manifest
    # NOTE: Non-GitOps Approach - Secret created imperatively
    # RATIONALE:
    # - This job is for development/bootstrapping only
    # - Production uses sealed secrets committed to Git
    # - Allows initial secret extraction without manual Keycloak console access
    # PRODUCTION APPROACH (GitOps):
    # 1. Run scripts/create-complete-sealed-secrets.sh to generate sealed secrets
    # 2. Commit sealed secrets to secrets/<env>/ directory
    # 3. ArgoCD deploys sealed secrets which are decrypted by sealed-secrets controller
    # 4. This job is disabled in production via environment overlays
    # SECURITY: This job runs PostSync so secrets are available after realm config
    cat <<EOF | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: $SECRET_NAME
      namespace: $NAMESPACE
    type: Opaque
    data:
    $(while IFS=: read -r key value; do
      key=$(echo "$key" | tr -d ' ')
      value=$(echo "$value" | tr -d ' ')
      echo "  $key: $(echo -n "$value" | base64)"
    done < "$SECRETS_FILE")
    EOF
    echo "Secret '$SECRET_NAME' created successfully in namespace '$NAMESPACE'."
    # Clean up
    rm "$SECRETS_FILE"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: keycloak-secret-exporter
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: keycloak-secret-exporter-role
rules:
- apiGroups: [""]
  resources: ["pods", "secrets"]
  verbs: ["get", "list", "create", "update"]
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: keycloak-secret-exporter-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: keycloak-secret-exporter-role
subjects:
- kind: ServiceAccount
  name: keycloak-secret-exporter
