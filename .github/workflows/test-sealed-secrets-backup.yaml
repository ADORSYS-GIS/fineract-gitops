name: Sealed Secrets Backup Validation

# Purpose: Periodically test sealed secrets disaster recovery procedures
# - Validates backups exist in AWS Secrets Manager
# - Tests restore procedure in isolated namespace
# - Alerts on failure

on:
  schedule:
    # Run monthly on the 1st at 02:00 UTC
    - cron: '0 2 1 * *'

  workflow_dispatch:
    # Allow manual triggering for testing
    inputs:
      environment:
        description: 'Environment to test (dev, uat, production)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - production
      skip_restore_test:
        description: 'Skip restore test (only check backup exists)'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  issues: write  # For creating GitHub issues on failure

env:
  AWS_REGION: us-east-1

jobs:
  validate-backup-exists:
    name: Validate Backup Exists
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [dev, uat, production]
      fail-fast: false  # Test all environments even if one fails

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Check backup exists in AWS Secrets Manager
        id: check_backup
        run: |
          set -e
          ENV="${{ matrix.environment }}"
          SECRET_PATH="/fineract/$ENV/sealed-secrets/master-key"

          echo "üîç Checking backup for environment: $ENV"
          echo "üìç AWS Secrets Manager path: $SECRET_PATH"

          # Check if secret exists
          if aws secretsmanager describe-secret --secret-id "$SECRET_PATH" 2>/dev/null; then
            echo "‚úÖ Backup exists"

            # Get backup metadata
            LAST_CHANGED=$(aws secretsmanager describe-secret --secret-id "$SECRET_PATH" --query 'LastChangedDate' --output text)
            VERSION_COUNT=$(aws secretsmanager list-secret-version-ids --secret-id "$SECRET_PATH" --query 'length(Versions)' --output text)

            echo "üìÖ Last changed: $LAST_CHANGED"
            echo "üì¶ Version count: $VERSION_COUNT"

            # Calculate age in days
            LAST_CHANGED_EPOCH=$(date -d "$LAST_CHANGED" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S" "$LAST_CHANGED" +%s)
            NOW_EPOCH=$(date +%s)
            AGE_DAYS=$(( (NOW_EPOCH - LAST_CHANGED_EPOCH) / 86400 ))

            echo "‚è∞ Backup age: $AGE_DAYS days"

            # Warn if backup is older than 90 days (should be refreshed during key rotation)
            if [ $AGE_DAYS -gt 90 ]; then
              echo "‚ö†Ô∏è WARNING: Backup is older than 90 days. Consider key rotation."
              echo "backup_age_warning=true" >> $GITHUB_OUTPUT
            fi

            echo "backup_exists=true" >> $GITHUB_OUTPUT
            echo "backup_age_days=$AGE_DAYS" >> $GITHUB_OUTPUT
            echo "version_count=$VERSION_COUNT" >> $GITHUB_OUTPUT
          else
            echo "‚ùå FAILURE: Backup does NOT exist in AWS Secrets Manager"
            echo "backup_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Validate backup structure
        run: |
          ENV="${{ matrix.environment }}"
          SECRET_PATH="/fineract/$ENV/sealed-secrets/master-key"

          echo "üîç Validating backup structure..."

          # Retrieve secret value
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id "$SECRET_PATH" --query 'SecretString' --output text)

          # Check required fields
          if echo "$SECRET_JSON" | jq -e '.keys' > /dev/null; then
            echo "‚úÖ 'keys' field exists"
          else
            echo "‚ùå FAILURE: Missing 'keys' field in backup"
            exit 1
          fi

          if echo "$SECRET_JSON" | jq -e '.metadata' > /dev/null; then
            echo "‚úÖ 'metadata' field exists"

            # Display metadata
            echo "üìã Backup metadata:"
            echo "$SECRET_JSON" | jq -r '.metadata | to_entries[] | "  \(.key): \(.value)"'
          else
            echo "‚ö†Ô∏è WARNING: Missing 'metadata' field (backup may be from old version)"
          fi

          # Check if keys are base64 encoded
          KEYS_BASE64=$(echo "$SECRET_JSON" | jq -r '.keys')
          if echo "$KEYS_BASE64" | base64 -d > /dev/null 2>&1; then
            echo "‚úÖ Keys are properly base64 encoded"
          else
            echo "‚ùå FAILURE: Keys are not valid base64"
            exit 1
          fi

          echo "‚úÖ Backup structure validation passed"

      - name: Create summary
        if: always()
        run: |
          ENV="${{ matrix.environment }}"

          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## Backup Validation: ${{ matrix.environment }}

          | Check | Status |
          |-------|--------|
          | Backup exists | ${{ steps.check_backup.outputs.backup_exists == 'true' && '‚úÖ Yes' || '‚ùå No' }} |
          | Backup age | ${{ steps.check_backup.outputs.backup_age_days || 'N/A' }} days |
          | Version count | ${{ steps.check_backup.outputs.version_count || 'N/A' }} |
          | Age warning | ${{ steps.check_backup.outputs.backup_age_warning == 'true' && '‚ö†Ô∏è >90 days' || '‚úÖ <90 days' }} |

          EOF

  test-restore-procedure:
    name: Test Restore Procedure (Dev Only)
    runs-on: ubuntu-latest
    needs: validate-backup-exists
    if: ${{ github.event_name == 'workflow_dispatch' && !inputs.skip_restore_test }}

    # Only test restore in dev environment (too risky for production)
    environment: dev

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBECONFIG_DEV }}

      - name: Create test namespace
        run: |
          NAMESPACE="sealed-secrets-dr-test-$(date +%s)"
          echo "TEST_NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

          echo "üèóÔ∏è Creating test namespace: $NAMESPACE"
          kubectl create namespace "$NAMESPACE"
          kubectl label namespace "$NAMESPACE" test=sealed-secrets-dr-drill

      - name: Deploy Sealed Secrets controller in test namespace
        run: |
          echo "üöÄ Deploying Sealed Secrets controller to test namespace..."

          # Use kustomization but override namespace
          cat <<EOF > /tmp/kustomization-test.yaml
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization

          namespace: $TEST_NAMESPACE

          resources:
            - ../../apps/sealed-secrets-controller/base

          patches:
            - patch: |-
                - op: replace
                  path: /metadata/namespace
                  value: $TEST_NAMESPACE
              target:
                kind: Deployment
                name: sealed-secrets-controller
          EOF

          kubectl apply -k /tmp/

          # Wait for controller to be ready
          echo "‚è≥ Waiting for controller to be ready..."
          kubectl wait --for=condition=available --timeout=120s \
            deployment/sealed-secrets-controller -n "$TEST_NAMESPACE"

          echo "‚úÖ Controller deployed successfully"

      - name: Restore keys from backup
        run: |
          ENV="${{ inputs.environment || 'dev' }}"
          SECRET_PATH="/fineract/$ENV/sealed-secrets/master-key"

          echo "üì• Restoring keys from AWS Secrets Manager..."
          echo "üìç Path: $SECRET_PATH"

          # Download backup
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_PATH" \
            --query 'SecretString' \
            --output text)

          # Extract and decode keys
          echo "$SECRET_JSON" | jq -r '.keys' | base64 -d > /tmp/sealed-secrets-keys.yaml

          # Apply keys to test namespace
          # Note: We need to patch the namespace in the YAML
          sed -i "s/namespace: kube-system/namespace: $TEST_NAMESPACE/g" /tmp/sealed-secrets-keys.yaml

          kubectl apply -f /tmp/sealed-secrets-keys.yaml -n "$TEST_NAMESPACE"

          echo "‚úÖ Keys restored to test namespace"

      - name: Restart controller with restored keys
        run: |
          echo "üîÑ Restarting controller to load restored keys..."

          kubectl rollout restart deployment/sealed-secrets-controller -n "$TEST_NAMESPACE"
          kubectl rollout status deployment/sealed-secrets-controller -n "$TEST_NAMESPACE" --timeout=120s

          echo "‚úÖ Controller restarted"

      - name: Test decryption with sample sealed secret
        run: |
          ENV="${{ inputs.environment || 'dev' }}"

          echo "üß™ Testing decryption with sample sealed secret..."

          # Copy a sealed secret from the environment to test namespace
          if kubectl get sealedsecret fineract-db-credentials -n "fineract-$ENV" > /dev/null 2>&1; then
            kubectl get sealedsecret fineract-db-credentials -n "fineract-$ENV" -o yaml \
              | sed "s/namespace: fineract-$ENV/namespace: $TEST_NAMESPACE/g" \
              | kubectl apply -f -

            # Wait for Secret to be created
            echo "‚è≥ Waiting for Secret to be decrypted..."

            for i in {1..30}; do
              if kubectl get secret fineract-db-credentials -n "$TEST_NAMESPACE" > /dev/null 2>&1; then
                echo "‚úÖ Secret successfully decrypted!"

                # Verify secret has data
                DATA_KEYS=$(kubectl get secret fineract-db-credentials -n "$TEST_NAMESPACE" -o jsonpath='{.data}' | jq -r 'keys[]')
                echo "üìã Secret contains keys: $DATA_KEYS"

                echo "decryption_success=true" >> $GITHUB_OUTPUT
                exit 0
              fi

              echo "  Attempt $i/30: Secret not yet created, waiting..."
              sleep 2
            done

            echo "‚ùå FAILURE: Secret was not decrypted within 60 seconds"

            # Check controller logs for errors
            echo "üìã Controller logs:"
            kubectl logs -n "$TEST_NAMESPACE" -l app.kubernetes.io/name=sealed-secrets --tail=50

            exit 1
          else
            echo "‚ö†Ô∏è WARNING: fineract-db-credentials sealed secret not found in $ENV, skipping decryption test"
          fi

      - name: Cleanup test namespace
        if: always()
        run: |
          echo "üßπ Cleaning up test namespace: $TEST_NAMESPACE"
          kubectl delete namespace "$TEST_NAMESPACE" --timeout=60s || true

      - name: Create restore test summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## Restore Procedure Test

          | Step | Status |
          |------|--------|
          | Test namespace created | ${{ steps.test_restore.outcome == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |
          | Controller deployed | ${{ steps.test_restore.outcome == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |
          | Keys restored | ${{ steps.test_restore.outcome == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |
          | Decryption test | ${{ steps.test_restore.outputs.decryption_success == 'true' && '‚úÖ Success' || '‚ùå Failed' }} |
          | Cleanup | ‚úÖ Complete |

          **Test Duration**: ~5 minutes

          EOF

  create-issue-on-failure:
    name: Create Issue on Failure
    runs-on: ubuntu-latest
    needs: [validate-backup-exists, test-restore-procedure]
    if: ${{ always() && (needs.validate-backup-exists.result == 'failure' || needs.test-restore-procedure.result == 'failure') }}

    steps:
      - name: Create GitHub issue
        uses: actions/github-script@v7
        with:
          script: |
            const title = 'üö® Sealed Secrets Backup Validation Failed';
            const body = `## Sealed Secrets Disaster Recovery Test Failed

            The automated sealed secrets backup validation has detected issues.

            ### Failure Details

            - **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            - **Date**: ${new Date().toISOString()}
            - **Triggered By**: ${{ github.event_name }}

            ### Failed Jobs

            - Backup Validation: ${{ needs.validate-backup-exists.result }}
            - Restore Test: ${{ needs.test-restore-procedure.result }}

            ### Immediate Actions Required

            1. **Check AWS Secrets Manager**: Verify backups exist for all environments
               \`\`\`bash
               aws secretsmanager list-secrets --filters Key=name,Values=/fineract/
               \`\`\`

            2. **Create Missing Backups**: Run backup script for affected environments
               \`\`\`bash
               ./scripts/backup-sealed-secrets-keys.sh dev
               ./scripts/backup-sealed-secrets-keys.sh uat
               ./scripts/backup-sealed-secrets-keys.sh production
               \`\`\`

            3. **Test Restore**: Validate restore procedure works
               \`\`\`bash
               ./scripts/validate-sealed-secrets-compatibility.sh
               \`\`\`

            4. **Review Logs**: Check workflow logs for specific error messages

            ### Related Documentation

            - [Sealed Secrets DR Runbook](/docs/SEALED_SECRETS_DR_RUNBOOK.md)
            - [Disaster Recovery Guide](/docs/DISASTER_RECOVERY.md)
            - [ADR-003: Sealed Secrets](/docs/architecture/ADR-003-sealed-secrets.md)

            ### Escalation

            If issue persists after following actions above, escalate to DevOps Lead.

            ---

            **Priority**: üî• High
            **Auto-generated by**: Sealed Secrets Backup Validation workflow
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['sealed-secrets', 'disaster-recovery', 'automated', 'high-priority']
            });

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [validate-backup-exists, test-restore-procedure]
    if: ${{ always() && needs.validate-backup-exists.result == 'success' }}

    steps:
      - name: Create success summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ‚úÖ Sealed Secrets DR Validation - All Checks Passed

          All sealed secrets backups are healthy and restore procedures validated.

          ## Summary

          - ‚úÖ All environment backups exist in AWS Secrets Manager
          - ‚úÖ Backup structures are valid
          - ‚úÖ Backup ages are within acceptable range
          - ‚úÖ Restore procedure tested successfully (if enabled)

          ## Next Steps

          - Review backup ages and plan key rotation if needed
          - Continue monthly validation schedule
          - No action required at this time

          ---

          **Next Scheduled Run**: 1st of next month at 02:00 UTC

          EOF

      # Optional: Slack notification for success (uncomment if you have Slack webhook)
      # - name: Notify Slack
      #   uses: slackapi/slack-github-action@v1
      #   with:
      #     webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
      #     payload: |
      #       {
      #         "text": "‚úÖ Sealed Secrets DR validation passed for all environments",
      #         "blocks": [
      #           {
      #             "type": "section",
      #             "text": {
      #               "type": "mrkdwn",
      #               "text": "*Sealed Secrets Disaster Recovery Validation*\n‚úÖ All checks passed\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
      #             }
      #           }
      #         ]
      #       }
