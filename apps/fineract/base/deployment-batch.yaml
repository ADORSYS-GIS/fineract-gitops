apiVersion: apps/v1
kind: Deployment
metadata:
  name: fineract-batch
  labels:
    app: fineract-batch
    component: batch-worker
spec:
  # Batch Worker Scaling Strategy:
  #
  # Default: replicas: 0 (scaled down to save resources)
  #
  # Why 0 replicas?
  # - Batch jobs are not continuously required
  # - Saves compute resources when no batch processing is needed
  # - Can be scaled up on-demand or on schedule
  #
  # Scaling Options:
  #
  # 1. Manual Scaling (for testing/ad-hoc jobs):
  #    kubectl scale deployment fineract-batch --replicas=1 -n <namespace>
  #
  # 2. Scheduled Scaling (for recurring batch jobs):
  #    Create a CronJob that scales the deployment up before batch window
  #    and scales it down after completion. Example:
  #    - Scale up: 0 0 * * * (daily at midnight)
  #    - Scale down: 0 6 * * * (daily at 6am after batch window)
  #
  # 3. Event-Driven Scaling (recommended for production):
  #    Use KEDA (Kubernetes Event-Driven Autoscaling) with triggers:
  #    - Queue depth (e.g., SQS, Kafka)
  #    - Database job table row count
  #    - Custom metrics (Prometheus)
  #
  # 4. HPA (Horizontal Pod Autoscaler):
  #    For scenarios where batch load varies, HPA can scale based on:
  #    - CPU/Memory utilization
  #    - Custom metrics (active batch jobs)
  #
  # Note: ArgoCD ignoreDifferences for replicas allows manual/HPA scaling
  # without GitOps conflicts (see argocd/applications/*/fineract.yaml)
  replicas: 0
  selector:
    matchLabels:
      app: fineract-batch
  template:
    metadata:
      labels:
        app: fineract-batch
    spec:
      serviceAccountName: fineract-aws
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 2000
        seccompProfile:
          type: RuntimeDefault

      # Wait for database schema migration to complete
      initContainers:
      - name: wait-for-schema-migration
        image: postgres:15-alpine
        securityContext:
          runAsNonRoot: true
          runAsUser: 999  # postgres user in official postgres image
          runAsGroup: 999
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "========================================="
          echo "Waiting for Fineract Schema Migration"
          echo "========================================="

          MAX_RETRIES=60
          RETRY_COUNT=0

          until [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
            if PGPASSWORD="${DB_PASSWORD}" psql \
              -h "${DB_HOST}" \
              -U "${DB_USER}" \
              -d "fineract_default" \
              -t -c "SELECT COUNT(*) FROM DATABASECHANGELOG;" > /dev/null 2>&1; then

              CHANGELOG_COUNT=$(PGPASSWORD="${DB_PASSWORD}" psql \
                -h "${DB_HOST}" \
                -U "${DB_USER}" \
                -d "fineract_default" \
                -t -c "SELECT COUNT(*) FROM DATABASECHANGELOG;" | tr -d ' ')

              echo "✓ Schema migration table exists with ${CHANGELOG_COUNT} changesets"

              LOCK_STATUS=$(PGPASSWORD="${DB_PASSWORD}" psql \
                -h "${DB_HOST}" \
                -U "${DB_USER}" \
                -d "fineract_default" \
                -t -c "SELECT LOCKED FROM DATABASECHANGELOGLOCK WHERE ID = 1;" | tr -d ' ')

              if [ "$LOCK_STATUS" = "f" ] || [ "$LOCK_STATUS" = "FALSE" ]; then
                echo "✓ No active Liquibase locks"
                echo "Schema migration completed successfully!"
                echo "========================================="
                exit 0
              else
                echo "⚠  Liquibase lock is still held, waiting..."
              fi
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Schema migration not complete yet (attempt $RETRY_COUNT/$MAX_RETRIES), waiting 10s..."
            sleep 10
          done

          echo "❌ Schema migration did not complete within timeout"
          exit 1
        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: password
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"

      containers:
      - name: fineract
        image: ghcr.io/adorsys-gis/fineract:db6c32ee9
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
        ports:
        - containerPort: 8080
          name: http
        env:
        # PostgreSQL Database Configuration
        - name: FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME
          value: "org.postgresql.Driver"
        - name: FINERACT_HIKARI_JDBC_URL
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: jdbc-url
        - name: FINERACT_HIKARI_USERNAME
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: username
        - name: FINERACT_HIKARI_PASSWORD
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: password

        # HikariCP Connection Pool Configuration
        - name: FINERACT_HIKARI_MINIMUM_IDLE
          value: "2"
        - name: FINERACT_HIKARI_MAXIMUM_POOL_SIZE
          value: "5"
        - name: FINERACT_HIKARI_IDLE_TIMEOUT
          value: "60000"  # 60 seconds
        - name: FINERACT_HIKARI_CONNECTION_TIMEOUT
          value: "20000"  # 20 seconds
        - name: FINERACT_HIKARI_MAX_LIFETIME
          value: "1800000"  # 30 minutes
        - name: FINERACT_HIKARI_LEAK_DETECTION_THRESHOLD
          value: "60000"  # 60 seconds
        - name: FINERACT_HIKARI_CONNECTION_TEST_QUERY
          value: "SELECT 1"

        # Tenant Database Configuration - AWS RDS PostgreSQL
        - name: FINERACT_DEFAULT_TENANTDB_HOSTNAME
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: host
        - name: FINERACT_DEFAULT_TENANTDB_PORT
          value: "5432"
        - name: FINERACT_DEFAULT_TENANTDB_IDENTIFIER
          value: "default"
        - name: FINERACT_DEFAULT_TENANTDB_NAME
          value: "fineract_default"
        - name: FINERACT_DEFAULT_TENANTDB_UID
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: username
        - name: FINERACT_DEFAULT_TENANTDB_PWD
          valueFrom:
            secretKeyRef:
              name: fineract-db-credentials
              key: password

        # Batch mode
        - name: FINERACT_MODE_READ_ENABLED
          value: "false"
        - name: FINERACT_MODE_WRITE_ENABLED
          value: "false"
        - name: FINERACT_MODE_BATCH_ENABLED
          value: "true"

        # S3 Configuration - AWS S3 with IRSA
        - name: FINERACT_CONTENT_S3_ENABLED
          value: "true"
        - name: FINERACT_CONTENT_S3_BUCKET_NAME
          valueFrom:
            secretKeyRef:
              name: s3-connection
              key: documents-bucket
        - name: FINERACT_CONTENT_S3_REGION
          valueFrom:
            secretKeyRef:
              name: s3-connection
              key: region
        # AWS credentials are provided via IRSA (IAM Roles for Service Accounts)
        # No need for static access keys - AWS SDK automatically uses IRSA credentials

        # Redis Cache Configuration
        - name: SPRING_CACHE_TYPE
          value: "redis"
        - name: SPRING_REDIS_HOST
          value: "fineract-redis"
        - name: SPRING_REDIS_PORT
          value: "6379"
        - name: SPRING_CACHE_REDIS_TIME_TO_LIVE
          value: "3600000"  # 1 hour in milliseconds
        - name: SPRING_CACHE_REDIS_KEY_PREFIX
          value: "fineract:cache:"

        # Disable Liquibase migrations in application pods
        # Migrations are handled by the dedicated fineract-schema-migration job
        # This prevents duplicate migration attempts and follows Fineract best practices (FINERACT-1882)
        - name: FINERACT_LIQUIBASE_ENABLED
          value: "false"

        # I18N ICU Configuration - Workaround for Yakworks Grails Library Bug
        #
        # Context:
        # - Apache Fineract uses the Yakworks Grails MessageSource library for i18n
        # - ICU (International Components for Unicode) provides advanced message formatting
        # - However, the Yakworks implementation has a known bug with ICU message formatting
        #
        # Bug Details:
        # - When ICU is enabled, message parameter substitution fails
        # - Error: "Missing closing '}' in message format"
        # - Affects validation messages, error messages, and user-facing strings
        # - Particularly impacts messages with parameters like: "Invalid value {0} for field {1}"
        #
        # Workaround:
        # - Set FINERACT_I18N_ICU_ENABLED=false to use standard MessageFormat
        # - Standard MessageFormat works correctly with the Yakworks library
        # - No functionality loss for typical Fineract i18n use cases
        #
        # Future Resolution:
        # - Monitor Yakworks Grails MessageSource library updates
        # - Test with ICU enabled when library is updated
        # - Re-enable ICU if/when bug is resolved
        #
        # Related:
        # - Fineract JIRA: [Add reference if available]
        # - Yakworks GitHub: https://github.com/yakworks/gorm-tools
        - name: FINERACT_I18N_ICU_ENABLED
          value: "false"

        # OAuth2 Configuration
        - name: FINERACT_SECURITY_BASICAUTH_ENABLED
          value: "false"
        - name: FINERACT_SECURITY_OAUTH_ENABLED
          value: "true"
        # Fineract OAuth Resource URL - REQUIRED for OAuth2 to work
        - name: FINERACT_SERVER_OAUTH_RESOURCE_URL
          valueFrom:
            configMapKeyRef:
              name: fineract-oauth2-config
              key: oidc-issuer-url
        # JWT Issuer URI - must match the 'iss' claim in JWT tokens from Keycloak
        # Keycloak issues tokens with HTTPS public-facing issuer
        - name: SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI
          valueFrom:
            configMapKeyRef:
              name: fineract-oauth2-config
              key: oidc-issuer-url
        # JWK Set URI for JWT token validation (internal Keycloak service)
        # Fineract uses this to fetch public keys to validate incoming JWT tokens
        - name: SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_JWK_SET_URI
          valueFrom:
            configMapKeyRef:
              name: fineract-oauth2-config
              key: jwk-set-uri-internal

        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"

        livenessProbe:
          httpGet:
            path: /fineract-provider/actuator/health
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 600  # 10 minutes for database migrations
          periodSeconds: 30

        readinessProbe:
          httpGet:
            path: /fineract-provider/actuator/health
            port: 8443
            scheme: HTTPS
          initialDelaySeconds: 120
          periodSeconds: 10
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}
